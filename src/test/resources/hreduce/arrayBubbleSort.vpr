field val: Int

domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function first(r: Ref): Array
  function second(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a,i)}
      first(loc(a,i)) == a && second(loc(a,i)) == i
  }

  axiom len_nonneg {
    forall a: Array :: { len(a) }
      len(a) >= 0
  }
}

receiver arrayRec(a: Array) (fun i: Int :: loc(a,i))
filter allInt(start: Int, end: Int) (fun i: Int :: i >= start && i < end )
filter twoInts(i1: Int, i2: Int) (fun i: Int :: i == i1 || i == i2 )
mapping singleM() (fun i: Int :: Multiset(i))
opWithId mUnion() (Multiset[Int](), fun a: Multiset[Int], b: Multiset[Int] :: a union b )

define access_array(a, i1, i2)
    (forall j: Int :: {j in allInt(i1,i2)} j in allInt(i1,i2) ==> acc(loc(a,j).val))
define mUnionfold(a, f)
    (hreduce[mUnion()](singleM(arrayRec(a).val) | f))

method swap(a:Array, i1: Int, i2: Int)
    requires acc(loc(a,i1).val) && acc(loc(a,i2).val)
    requires i1 >= 0 && i1 < len(a) && i2 >= 0 && i2 < len(a)
    ensures acc(loc(a,i1).val) && acc(loc(a,i2).val)
    ensures mUnionfold(a,twoInts(i1,i2)) ==
           old(mUnionfold(a,twoInts(i1,i2)))
{

    var temp: Int := loc(a,i1).val
    loc(a,i1).val := loc(a,i2).val
    loc(a,i2).val := temp
}

method bubbleSort(a: Array)
    requires access_array(a, 0, len(a))
    ensures access_array(a, 0, len(a))
    ensures mUnionfold(a, allInt(0,len(a))) == old(mUnionfold(a, allInt(0,len(a))))
{
    var n : Int := len(a)
    var swapped : Bool := true
    while(swapped)
        invariant access_array(a, 0, len(a))
        invariant mUnionfold(a, allInt(0,len(a))) == old(mUnionfold(a, allInt(0,len(a))))
    {
        swapped := false
        var i : Int := 1
        while(i < len(a))
            invariant access_array(a, 0, len(a))
            invariant mUnionfold(a, allInt(0,len(a))) == old(mUnionfold(a, allInt(0,len(a))))
        {
            assert i in allInt(0,len(a)) && i-1 in allInt(0, len(a))
            if (loc(a,i - 1).val > loc(a,i).val) {
                swap(a, i-1, i)
                swapped := true
            }
        }
    }
}

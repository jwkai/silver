field val: Int

domain Array {
  function loc(a: Array, i: Int): Ref
  function len(a: Array): Int
  function first(r: Ref): Array
  function second(r: Ref): Int

  axiom all_diff {
    forall a: Array, i: Int :: {loc(a,i)}
      first(loc(a,i)) == a && second(loc(a,i)) == i
  }

  axiom len_nonneg {
    forall a: Array :: { len(a) }
      len(a) >= 0
  }
}

receiver arrayRec(a: Array) (fun i: Int :: loc(a,i))
filter allInt(start: Int, end: Int) (fun i: Int :: i >= start && i < end )
identityOp add() (0 ,fun a: Int, b: Int :: a + b )
define access_array(a, i1, i2)
    (forall j: Int :: {loc(a,j)} i1 <= j && j < i2 ==> acc(loc(a,j).val))

method test1(i0: Int, a:Array)
    requires access_array(a, 0, len(a))
    requires len(a) > 10
    requires i0 in allInt(0,len(a))
{
    var i1 : Int
    assume i1 in allInt(0,len(a))
    var i2 : Int
    assume i2 in allInt(0,len(a))
    var i3 : Int
    assume i3 in allInt(0,len(a))
    var i4 : Int
    assume i4 in allInt(0,len(a))
    var i5 : Int
    assume i5 in allInt(0,len(a))
    loc(a,i0).val := loc(a,i0).val + 1
    loc(a,i1).val := loc(a,i1).val + 1
    loc(a,i2).val := loc(a,i2).val + 1
    loc(a,i3).val := loc(a,i3).val + 1
    loc(a,i4).val := loc(a,i4).val + 1
    loc(a,i5).val := loc(a,i5).val + 1
    assert hfold[add()](arrayRec(a).val | allInt(0,len(a))) ==
        old(hfold[add()](arrayRec(a).val | allInt(0,len(a)))) + 6
}

receiver das(a: Array) (fun i: Int :: loc(a,i))

domain Array {
    function loc(a: Array, i: Int): Ref
}

domain someR[A] {
    function getR(i: Int): Ref
}



filter allInt(start: Int, end: Int) (fun i: Int :: i >= start && i < end )
identityOp add(x: Int) (-x ,fun a: Int, b: Int :: a + b + x)
identityOp and() (true, fun a: Bool, b: Bool :: a && b)



receiver unitRec() (fun i: Int :: getR(i))
mapping unitMap()  (fun a: Int :: a)


method nothing(aha: Int) returns (res: Int)
    requires aha != 0
    ensures aha == 1
    ensures res == 1

field val: Int
field taken: Bool

method test1(i1: Int, r: Ref)
    requires acc(r.val)
    requires acc(r.taken)
{
    exhale acc(r.val)
    inhale acc(r.val)

    r.val := r.val + 1

    var b: Int := comp[add(1)]{unitMap(unitRec().val) | allInt(0,10)}
    assume false

}

receiver das(a: Array) (fun i: Int :: loc(a,i))

domain Array {
    function loc(a: Array, i: Int): Ref
}

domain someR[A] {
    function getR(i: Int): Ref
}



filter allInt(start: Int, end: Int) (fun i: Int :: i >= start && i < end )
unitOp add(x: Int) (-x ,fun a: Int, b: Int :: a + b + x)
unitOp and() (true, fun a: Bool, b: Bool :: a && b)



receiver unitRec() (fun i: Int :: getR(i))
mapping unitMap()  (fun a: Int :: a)


method nothing(aha: Int) returns (res: Int)
    requires aha != 0
    ensures aha == 1
    ensures res == 1

field val: Int
field taken: Bool

method test1(i1: Int, r: Ref)
    requires acc(r.val)
    requires acc(r.taken)
{
    var dum: Int

    var a: Bool := true

    assert a == true
    assume dum == 1
    dum := nothing(dum)

    assume r.val == 2
    assume r.taken == true

    exhale acc(r.val)
    inhale acc(r.val)



    var b: Int := comp[add(1)]{unitMap(unitRec().val) | allInt(0,10)}
    var c: Int := comp[add(1)]{unitRec().val | allInt(0,10)}
    var d: Bool := comp[and()]{ unitRec().taken | allInt(0,4)}

    assume false

}

domain Receiver[A] {
    function eval(r:Receiver[A], a:A): Ref
    function inverseval(re:Receiver[A], r:Ref): A
    function filterReceiverGood(f: Set[A], r: Receiver[A]) : Bool
    function identityReceiver(): Receiver[A]
}

domain Operator[A] {
    function oper(op: Operator[A], a1: A, a2: A) : A
    function and() : Operator[A]
}


domain Mapping[V,B] {
    function applyMap(m: Mapping[V,B], val: V) : B
    function identityMap(a : Bool): Mapping[V,V]

}

domain Comp[A,V,B] {
    function comp(r:Receiver[A], m: Mapping[V,B],
        op: Operator[B],u: B) : Comp[A,V,B]
}

function filter1(start: Int, end: Int): Set[Bool]

domain CompEval[A,V,B] {
    function evalComp(c: Comp[A,V,B], snap: Map[A,B]) : B
}

field val: Bool

method test1(i1: Int) {
    var a: Bool := true

    var b: Bool := comp[and(),true]{identityMap(identityReceiver().val, false) | filter1(0,10)}

    assert(b == true)
}
